#!/usr/local/bin/node

String.prototype.repeat = function( num )
{
    return new Array( num + 1 ).join( this );
}

var fs = require("fs");
var util = require('util');

// Load up our heuristics

var scans = parseTabTree(fs.readFileSync('heur.txt').toString());

/**
 * dir: path to the directory to explore
 * action(file, stat): called on each file or until an error occurs. file: path to the file. stat: stat of the file (retrived by fs.stat)
 * done(err): called one time when the process is complete. err is undifined is everything was ok. the error that stopped the process otherwise
 */
var walk = function(dir, action, done) {

	// this flag will indicate if an error occured (in this case we don't want to go on walking the tree)
	var dead = false;

	// this flag will store the number of pending async operations
	var pending = 0;

	var fail = function(err) {
		if(!dead) {
			dead = true;
			done(err);
		}
	};

	var checkSuccess = function() {
		if(!dead && pending == 0) {
			done();
		}
	};

	var performAction = function(file, stat) {
		if(!dead) {
			try {
				action(file, stat);
			}
			catch(error) {
				fail(error);
			}
		}
	};

	// this function will recursively explore one directory in the context defined by the variables above
	var dive = function(dir) {
		pending++; // async operation starting after this line
		fs.readdir(dir, function(err, list) {
			if(!dead) { // if we are already dead, we don't do anything
				if (err) {
					fail(err); // if an error occured, let's fail
				}
				else { // iterate over the files
					list.forEach(function(file) {
						if(!dead) { // if we are already dead, we don't do anything
							var path = dir + "/" + file;
							pending++; // async operation starting after this line
							fs.stat(path, function(err, stat) {
								if(!dead) { // if we are already dead, we don't do anything
									if (err) {
										fail(err); // if an error occured, let's fail
									}
									else {
										if (stat && stat.isDirectory()) {
											dive(path); // it's a directory, let's explore recursively
										}
										else {
											performAction(path, stat); // it's not a directory, just perform the action
										}
										pending--; checkSuccess(); // async operation complete
									}
								}
							});
						}
					});
					pending--; checkSuccess(); // async operation complete
				}
			}
		});
	};

	// start exploration
	dive(dir);
};

console.log("###\n\
# Scan Started\n\
#\n\
");

walk(process.cwd()+'/test', function walkstep(file, stat) {
	console.log('Scanning a file: '+file);

	for (ix in scans[''][0]) {
		re = new RegExp(ix);
		// File type to check
		if (m = file.match(re)) {
			fs.readFile(file, function (err, data, ix) {
				rescan = new RegExp(scans[''][0][this.ix][0].report[0].value);
				if (data.toString().match(rescan)) {
					console.log('Found malware: '+file);
				}
			}.bind( {ix: ix} ));
		}
	}

}, function walkdone() {
})

function parseTabTree(data) {
	var root = { value: 'root' }, obj = root, current = '', lines = data.split('\r\n'), curDepth = -1;
	for (ix in lines) {
		var line = lines[ix].replace(/^\s+/, '');
		var depth = lines[ix].match(/^[\s]*/g)[0].length;
		// Shallow, push our current value in and switch target up a level.
		if (depth < curDepth) {
			obj.value = current;
			for (var cl = curDepth - depth; cl > 0; --cl) obj = obj.parent;
			last = current = '';
		}
		// Deep, push our current target to parent and step down a level.
		else if (depth > curDepth) {
			nobj = {parent: obj, value: current};
			if (!obj[current]) obj[current] = [];
			obj[current].push(nobj);
			obj = nobj;
			current = '';
		}
		// Across
		else obj.value += current;
		current += line;
		curDepth = depth;
	}
	return root;
}
